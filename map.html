<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Traffic Cameras Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    body {
      margin: 0;
      background-color: #121212;
      color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    .section-title {
      margin: 0;
      padding: 1em 1em 0 1em;
      font-size: 1.4em;
      font-weight: bold;
      color: #f0f0f0;
      background-color: #1e1e1e;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1em;
      padding: 1em;
      background: #1e1e1e;
    }
    select {
      background: #333;
      color: #fff;
      border: none;
      padding: 0.5em;
    }
    #map {
      width: 100%;
      height: 100vh;
    }
    .camera-grid {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      padding: 1em;
      gap: 1em;
      background-color: #121212;
    }
    .camera-box {
      background-color: #1e1e1e;
      border: 1px solid #333;
      padding: 1em;
      border-radius: 8px;
      width: 320px;
      text-align: center;
      box-shadow: 0 0 8px rgba(0,0,0,0.6);
    }
    .camera-box img, .camera-box video {
      max-width: 100%;
      border-radius: 4px;
      margin-top: 0.5em;
      cursor: pointer;
    }
    .camera-name {
      font-weight: bold;
      font-size: 1.1em;
      margin-bottom: 0.5em;
    }
    .coords {
      font-size: 0.9em;
      color: #aaa;
    }
    .timestamp {
      font-size: 0.8em;
      color: #ccc;
      margin-top: 0.5em;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal img, .modal video {
      max-width: 90%;
      max-height: 90%;
    }
      @keyframes pulse {
      0% { stroke-width: 2px; }
      50% { stroke-width: 6px; }
      100% { stroke-width: 2px; }
    }
    .emergency {
      animation: pulse 1.5s infinite;
      stroke: #ff69b4 !important;
    }
    .destructive {
      animation: pulse 1s infinite;
      stroke: #ffb833 !important;
    }

  </style>
</head>
<body>
<h2 class="section-title">Weather Alerts & Cameras Viewer</h2>
<div id="controls">
  <button id="homeBtn" style="background:#333;color:#fff;border:none;padding:0.5em 1em;border-radius:4px;cursor:pointer;font-weight:bold;margin-right:1em;">
    Home
  </button>
  <label>Route:
    <select id="routeFilter">
      <option value="all">All</option>
      <option value="I10">I-10</option>
      <option value="I30">I-30</option>
      <option value="I35">I-35</option>
      <option value="I40">I-40</option>
      <option value="I45">I-45</option>
      <option value="I49">I-49</option>
      <option value="I55">I-55</option>
      <option value="I57">I-57</option>
      <option value="I430">I-430</option>
      <option value="I440">I-440</option>
      <option value="I530">I-530</option>
      <option value="I540">I-540</option>
      <option value="I555">I-555</option>
      <option value="I630">I-630</option>
      <option value="US1">US-1</option>
      <option value="US62">US-62</option>
      <option value="US63">US-63</option>
      <option value="US65">US-65</option>
      <option value="US69">US-69</option>
      <option value="US69">US-70</option>
      <option value="US71">US-71</option>
      <option value="US166">US-166</option>
      <option value="US270">US-270</option>
      <option value="US400">US-400</option>
      <option value="US412">US-412</option>
      <option value="statehwy">State Highways</option>
    </select>
  </label>
  <label>State:
    <select id="stateFilter">
      <option value="all">All</option>
      <option value="Alabama">Alabama</option>
      <option value="Arkansas">Arkansas</option>
      <option value="Florida">Florida</option>
      <option value="Georgia">Georgia</option>
      <option value="Illinois">Illinois</option>
      <option value="Kansas">Kansas</option>
      <option value="Louisiana">Louisiana</option>
      <option value="Missouri">Missouri</option>
      <option value="Mississippi">Mississippi</option>
      <option value="Oklahoma">Oklahoma</option>
      <option value="Tennessee">Tennessee</option>
      <option value="Texas">Texas</option>
      <option value="International">International</option>
    </select>
  </label>
  <label>State Region:
    <select id="regionFilter">
      <option value="all">All</option>
      <option value="northern">Northern</option>
      <option value="eastern">Eastern</option>
      <option value="central">Central</option>
      <option value="southern">Southern</option>
      <option value="western">Western</option>
    </select>
  </label>
    <label>Network:
    <select id="networkFilter">
      <option value="all">All</option>
      <option value="DOT">DOT</option>
      <option value="news">News Stations</option>
      <option value="weatherbug">WeatherBug</option>
      <option value="weatherstem">WeatherStem</option>
      <option value="other">Other</option>
    </select>
  </label>
</div>

<div id="map"></div>
<div class="camera-grid" id="cameraGrid"></div>
<div class="modal" id="modal" onclick="this.style.display='none';"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<script> 
  const warningColors = {
        "Tsunami Warning": "#FD6347",
        "Tornado Warning": "#FF0000",
        "Extreme Wind Warning": "#FF8C00",
        "Severe Thunderstorm Warning": "#FFA500",
        "Flash Flood Warning": "#8B0000",
        "Flash Flood Statement": "#8B0000",
        "Severe Weather Statement": "#00FFFF",
        "Shelter In Place Warning": "#FA8072",
        "Evacuation Immediate": "#5FBF00",
        "Civil Danger Warning": "#FFB6C1",
        "Nuclear Power Plant Warning": "#4B0082",
        "Radiological Hazard Warning": "#4B0082",
        "Hazardous Materials Warning": "#4B0082",
        "Fire Warning": "#A0522D",
        "Civil Emergency Message": "#FFB6C1",
        "Law Enforcement Warning": "#C0C0C0",
        "Storm Surge Warning": "#B524F7",
        "Hurricane Force Wind Warning": "#CD5C5C",
        "Hurricane Warning": "#DC143C",
        "Typhoon Warning": "#DC143C",
        "Special Marine Warning": "#FFA500",
        "Blizzard Warning": "#FF4500",
        "Snow Squall Warning": "#C71585",
        "Ice Storm Warning": "#8B008B",
        "Heavy Freezing Spray Warning": "#00BFFF",
        "Winter Storm Warning": "#FF69B4",
        "Lake Effect Snow Warning": "#008B8B",
        "Dust Storm Warning": "#FFE4C4",
        "Blowing Dust Warning": "#FFE4C4",
        "High Wind Warning": "#DAA520",
        "Tropical Storm Warning": "#B22222",
        "Storm Warning": "#9400D3",
        "Tsunami Advisory": "#D2691E",
        "Tsunami Watch": "#FF00FF",
        "Avalanche Warning": "#1E90FF",
        "Earthquake Warning": "#8B4513",
        "Volcano Warning": "#2F4F4F",
        "Ashfall Warning": "#A9A9A9",
        "Flood Warning": "#00FF00",
        "Coastal Flood Warning": "#228B22",
        "Lakeshore Flood Warning": "#228B22",
        "Ashfall Advisory": "#696969",
        "High Surf Warning": "#228B22",
        "Extreme Heat Warning": "#C71585",
        "Tornado Watch": "#FFFF00",
        "Severe Thunderstorm Watch": "#DB7093",
        "Flash Flood Watch": "#2E8B57",
        "Gale Warning": "#DDA0DD",
        "Flood Statement": "#00FF00",
        "Extreme Cold Warning": "#0000FF",
        "Freeze Warning": "#483D8B",
        "Red Flag Warning": "#FF1493",
        "Storm Surge Watch": "#DB7FF7",
        "Hurricane Watch": "#FF00FF",
        "Hurricane Force Wind Watch": "#9932CC",
        "Typhoon Watch": "#FF00FF",
        "Tropical Storm Watch": "#F08080",
        "Storm Watch": "#FFE4B5",
        "Tropical Cyclone Local Statement": "#FFE4B5",
        "Tropical Cyclone Statement": "#FFE4B5",
        "Winter Weather Advisory": "#7B68EE",
        "Avalanche Advisory": "#CD853F",
        "Cold Weather Advisory": "#AFEEEE",
        "Heat Advisory": "#FF7F50",
        "Flood Advisory": "#00FF7F",
        "Coastal Flood Advisory": "#7CFC00",
        "Lakeshore Flood Advisory": "#7CFC00",
        "High Surf Advisory": "#BA55D3",
        "Dense Fog Advisory": "#708090",
        "Dense Smoke Advisory": "#F0E68C",
        "Small Craft Advisory": "#D8BFD8",
        "Brisk Wind Advisory": "#D8BFD8",
        "Hazardous Seas Warning": "#D8BFD8",
        "Dust Advisory": "#BDB76B",
        "Blowing Dust Advisory": "#BDB76B",
        "Lake Wind Advisory": "#D2B48C",
        "Wind Advisory": "#D2B48C",
        "Frost Advisory": "#6495ED",
        "Freezing Fog Advisory": "#008080",
        "Freezing Spray Advisory": "#00BFFF",
        "Low Water Advisory": "#A52A2A",
        "Local Area Emergency": "#C0C0C0",
        "Winter Storm Watch": "#4682B4",
        "Rip Current Statement": "#40E0D0",
        "Beach Hazards Statement": "#40E0D0",
        "Gale Watch": "#FFC0CB",
        "Avalanche Watch": "#F4A460",
        "Hazardous Seas Watch": "#483D8B",
        "Heavy Freezing Spray Watch": "#BC8F8F",
        "Flood Watch": "#2E8B57",
        "Coastal Flood Watch": "#66CDAA",
        "Lakeshore Flood Watch": "#66CDAA",
        "High Wind Watch": "#B8860B",
        "Extreme Heat Watch": "#800000",
        "Extreme Cold Watch": "#5F9EA0",
        "Freeze Watch": "#00FFFF",
        "Fire Weather Watch": "#FFDEAD",
        "Extreme Fire Danger": "#E9967A",
        "911 Telephone Outage": "#C0C0C0",
        "Coastal Flood Statement": "#6B8E23",
        "Lakeshore Flood Statement": "#6B8E23",
        "Special Weather Statement": "#FFE4B5",
        "Marine Weather Statement": "#FFDAB9",
        "Air Quality Alert": "#808080",
        "Air Stagnation Advisory": "#808080",
        "Hazardous Weather Outlook": "#EEE8AA",
        "Hydrologic Outlook": "#90EE90",
        "Short Term Forecast": "#98FB98",
        "Administrative Message": "#C0C0C0",
        Default: "#000000", // Default to black if no match
};

let warningPolygons = [];
let usCountyGeoJson = null;
let cachedCanadianAlerts = {};

fetch("https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json")
  .then((res) => res.json())
  .then((data) => {
    usCountyGeoJson = data;
  });

async function fetchWarnings() {
  try {
    const response = await fetch("https://api.weather.gov/alerts/active");
    const data = await response.json();

    const now = new Date();
    const uniqueWarnings = {};

    const validWarnings = data.features.filter((warning) => {
      const expires = new Date(warning.properties.expires);
      const id = warning.id;
      if (expires > now && !uniqueWarnings[id]) {
        uniqueWarnings[id] = true;
        return true;
      }
      return false;
    });

    const emergencyWarnings = [];
    const destructiveWarnings = [];
    const regularWarnings = [];

    validWarnings.forEach((warning) => {
      const desc = warning.properties.description || "";
      if (desc.includes("FLASH FLOOD EMERGENCY") || desc.includes("TORNADO EMERGENCY")) {
        emergencyWarnings.push(warning);
      } else if (desc.includes("DESTRUCTIVE STORMS") || desc.includes("DESTRUCTIVE STORM")) {
        destructiveWarnings.push(warning);
      } else {
        regularWarnings.push(warning);
      }
    });

    const sortedWarnings = [
      ...regularWarnings.sort(
        (a, b) => new Date(a.properties.sent) - new Date(b.properties.sent)
      ),
      ...destructiveWarnings,
      ...emergencyWarnings,
    ];

    if (!usCountyGeoJson) {
      console.warn("County geojson not ready yet.");
      return;
    }

    displayWarningsOnMap(sortedWarnings, emergencyWarnings, destructiveWarnings);
  } catch (error) {
    console.error("Error fetching warnings:", error);
  }
}

function displayWarningsOnMap(warnings, emergencyWarnings, destructiveWarnings) {
  warningPolygons.forEach(p => map.removeLayer(p));
  warningPolygons = [];

  if (!map.getPane("fallbackPolygons")) {
    map.createPane("fallbackPolygons");
    map.getPane("fallbackPolygons").style.zIndex = 300;
  }

  warnings.forEach((warning) => {
    const expires = new Date(warning.properties.expires);
    const fipsCodes = (warning.properties.geocode?.SAME || []).map(c =>
      c.padStart(5, "0").slice(-5)
    );

    function getTimeRemaining() {
      const now = new Date();
      const timeLeft = expires - now;
      if (timeLeft <= 0) return "Expired";
      const minutes = Math.floor((timeLeft / 1000 / 60) % 60);
      const hours = Math.floor(timeLeft / 1000 / 60 / 60);
      return `${hours}h ${minutes}m`;
    }

    if (warning.geometry?.type === "Polygon") {
      const coordinates = warning.geometry.coordinates[0].map(coord => [
        coord[1],
        coord[0],
      ]);

      let color = warningColors[warning.properties.event] || warningColors.Default;
      let weight = 4;
      let className = "";

      if (emergencyWarnings.includes(warning)) {
        color = "#FF69B4";
        weight = 6;
        className = "emergency";
      } else if (destructiveWarnings.includes(warning)) {
        color = "#AB7800";
        weight = 6;
        className = "destructive";
      }

      const polygon = L.polygon(coordinates, {
        color,
        weight,
        opacity: 1,
        fillOpacity: 0.45,
        className
      }).bindPopup(`
        <strong>Event:</strong> ${warning.properties.event}<br>
        <strong>Sender:</strong> ${warning.properties.senderName || "N/A"}<br>
        <strong>Area(s):</strong> ${warning.properties.areaDesc || "N/A"}<br>
        <strong>Sent:</strong> ${new Date(warning.properties.sent).toLocaleString()}<br>
        <strong>Expires:</strong> ${expires.toLocaleString()}<br>
        <strong>Time Remaining:</strong> ${getTimeRemaining()}<br>
      `);

      polygon.addTo(map);
      if (className) polygon.bringToFront();
      warningPolygons.push(polygon);

    } else if (fipsCodes.length && usCountyGeoJson) {
      const fallbackColor = warningColors[warning.properties.event] || "#999";

      usCountyGeoJson.features.forEach(feature => {
        if (fipsCodes.includes(feature.id)) {
          const geom = feature.geometry;
          const polys = geom.type === "Polygon" ? [geom.coordinates] : geom.coordinates;

          polys.forEach(p => {
            const latlngs = p[0].map(coord => [coord[1], coord[0]]);
            const polygon = L.polygon(latlngs, {
              color: fallbackColor,
              weight: 3,
              opacity: 0.65,
              fillOpacity: 0.25,
              pane: "fallbackPolygons"
            }).bindPopup(`
              <strong>Event:</strong> ${warning.properties.event}<br>
              <strong>Sender:</strong> ${warning.properties.senderName || "N/A"}<br>
              <strong>Area(s):</strong> ${warning.properties.areaDesc || "N/A"}<br>
              <strong>Sent:</strong> ${new Date(warning.properties.sent).toLocaleString()}<br>
              <strong>Expires:</strong> ${expires.toLocaleString()}<br>
            `);

            polygon.addTo(map);
            warningPolygons.push(polygon);
          });
        }
      });
    }
  });
}

const map = L.map('map').setView([36.3, -94.4], 7);
L.tileLayer('https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: 'Â© OpenStreetMap'
}).addTo(map);

fetchWarnings();
setInterval(fetchWarnings, 10000);

// Create a custom pane for radar
map.createPane('radarPane');
map.getPane('radarPane').style.zIndex = 300;

// Add radar layer to the radarPane
let radarLayer = L.tileLayer
  .wms("https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?", {
    layers: "nexrad-n0q-900913",
    format: "image/png",
    transparent: true,
    attribution: "Iowa Environmental Mesonet",
    pane: "radarPane" // <-- assign to radarPane
  })
  .addTo(map);

function refreshRadarLayer() {
  map.removeLayer(radarLayer);
  radarLayer = L.tileLayer
    .wms(
      "https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?",
      {
        layers: "nexrad-n0q-900913",
        format: "image/png",
        transparent: true,
        attribution: "Iowa Environmental Mesonet",
        pane: "radarPane" // <-- assign to radarPane
      }
    )
    .addTo(map);
}

let lastUpdateTime = null;

async function conditionalRefreshRadarLayer() {
  const response = await fetch(
    "https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?"
  );
  const currentUpdateTime = response.headers.get("Last-Modified");

  if (currentUpdateTime && currentUpdateTime !== lastUpdateTime) {
    lastUpdateTime = currentUpdateTime;
    refreshRadarLayer();
  }
}

setInterval(conditionalRefreshRadarLayer, 60000); // Check every 60 seconds

const PROXY_BASE = '';
let cameras = [];
let lastUpdated = new Date();

fetch('cameras.json')
  .then(res => res.json())
  .then(data => {
    cameras = data.filter(cam => {
    return !('_comment' in cam) && cam.id && cam.coords && cam.coords.length === 2;
  });
  
    console.log('Loaded cameras:', cameras.length);

    cameras.forEach(cam => {
      if (!cam.coords || cam.coords.length !== 2) return;

      const marker = L.marker(cam.coords, { icon: cameraIcon });
      const src = cam.src || getImageUrl(cam.id);

      const popupContent =
        cam.type === 'image'
          ? `<strong>${cam.name}</strong><br><img src="${src}" width="300">`
          : cam.type === 'iframe'
            ? `<strong>${cam.name}</strong><br><iframe src="${cam.src}" width="300" height="200" frameborder="0" allowfullscreen></iframe>`
            : `<strong>${cam.name}</strong><br><video width="300" src="${cam.src}" autoplay muted loop></video>`;

      marker.bindPopup(popupContent);
      markerCluster.addLayer(marker);
    });

    map.addLayer(markerCluster);

  // Make sure camera markers are always on top
  if (typeof markerCluster !== "undefined") {
    markerCluster.bringToFront();
  }

    updateCameraGrid();
  });

const cameraIcon = L.icon({
  iconUrl: 'https://cdn-icons-png.flaticon.com/512/66/66843.png',
  iconSize: [30, 30],
  iconAnchor: [15, 30]
});

const markerCluster = L.markerClusterGroup();

function getImageUrl(id) {
  return `https://actis.idrivearkansas.com/index.php/api/cameras/image?camera=${id}`;
}

function buildCameraBox(cam) {
  const box = document.createElement('div');
  box.className = 'camera-box';
  box.setAttribute('data-state', cam.state);
  box.setAttribute('data-route', cam.route);

  let media, src;

  if (cam.type === 'image') {
    src = cam.src || getImageUrl(cam.id);
    media = `<img id="img-${cam.id}" src="${src}" alt="${cam.name}" onclick="showModal(this.src)">`;
  } else if (cam.type === 'iframe') {
    src = cam.proxy ? PROXY_BASE + encodeURIComponent(cam.rawSrc) : cam.src;
    media = `<iframe src="${src}" width="300" height="200" frameborder="0" allowfullscreen></iframe>`;
  } else {
    src = cam.proxy ? PROXY_BASE + encodeURIComponent(cam.rawSrc) : cam.src;
    media = `<video id="vid-${cam.id}" controls autoplay muted loop src="${src}" onclick="event.stopPropagation(); showModalVideo(this.src)"></video>`;
  }

  box.innerHTML = `
    <div class="camera-name">${cam.name}</div>
    <div class="coords">${cam.coords.map(c => c.toFixed(5)).join(', ')}</div>
    ${media}
    <div class="timestamp" id="ts-${cam.id}">Updated: ${lastUpdated.toLocaleTimeString()}</div>
  `;
  
  return box;
}

function updateCameraGrid() {
  const routeFilter = document.getElementById('routeFilter').value;
  const stateFilter = document.getElementById('stateFilter').value;
  const regionFilter = document.getElementById('regionFilter').value;
  const networkFilter = document.getElementById('networkFilter').value;
  const grid = document.getElementById('cameraGrid');
  grid.innerHTML = '';
  cameras.forEach(cam => {
    if ((routeFilter === 'all' || cam.route === routeFilter) && (stateFilter === 'all' || cam.state === stateFilter) && (regionFilter === 'all' || cam.region === regionFilter) && (networkFilter === 'all' || cam.network === networkFilter)){
      grid.appendChild(buildCameraBox(cam));
    }
  });
}

function showModal(src) {
  const modal = document.getElementById('modal');
  modal.innerHTML = `<img src="${src}">`;
  modal.style.display = 'flex';
}

function showModalVideo(src) {
  const modal = document.getElementById('modal');
  modal.innerHTML = `<video src="${src}" controls autoplay style="max-width:90%; max-height:90%"></video>`;
  modal.style.display = 'flex';
}

// Update images every 30s
setInterval(() => {
  lastUpdated = new Date();
  cameras.forEach(cam => {
    if (cam.type === 'image') {
      const img = document.getElementById(`img-${cam.id}`);
      if (img) {
        const src = cam.src || getImageUrl(cam.id);
        img.src = `${src}${src.includes('?') ? '&' : '?'}t=${Date.now()}`;
        console.log(`Updated ${cam.id} at ${lastUpdated.toLocaleTimeString()}`);
      }
    }
    const ts = document.getElementById(`ts-${cam.id}`);
    if (ts) ts.textContent = `Updated: ${lastUpdated.toLocaleTimeString()}`;
  });
}, 30000);

// Filters
['routeFilter', 'stateFilter', 'regionFilter', 'networkFilter'].forEach(id => {
  document.getElementById(id).addEventListener('change', updateCameraGrid);
});

updateCameraGrid();

document.getElementById('homeBtn').addEventListener('click', function() {
  window.location.href = 'index.html';
});

// --- RealEarth Layers Section ---

// Create a custom pane for RealEarth layers (once, after map is created)
map.createPane('realEarthPane');
map.getPane('realEarthPane').style.zIndex = 200; // Above base tiles, below overlays

// Create a custom pane for ProbSevere above all others
map.createPane('probSeverePane');
map.getPane('probSeverePane').style.zIndex = 400; // Above other overlays

// Helper to create and style RealEarth GeoJSON layers
function createRealEarthLayer(url, paneName = 'realEarthPane') {
  const layer = L.layerGroup();
  layer._realEarthUrl = url;
  layer._geoJsonLayer = null;

  async function loadData() {
    try {
      const res = await fetch(url);
      const data = await res.json();

      if (layer._geoJsonLayer) {
        layer.removeLayer(layer._geoJsonLayer);
      }

      layer._geoJsonLayer = L.geoJSON(data, {
        pane: paneName, // Use the specified pane
        style: feature => ({
          color: rgbString(feature.properties.BCOLOR) || rgbString(feature.properties.COLOR) || '#00bfff',
          weight: 2,
          opacity: (feature.properties.BOPACITY ?? 100) / 100,
          fillColor: rgbString(feature.properties.COLOR) || rgbString(feature.properties.BCOLOR) || '#00bfff',
          fillOpacity: (feature.properties.OPACITY ?? 50) / 100
        }),
        onEachFeature: (feature, layerObj) => {
          const title = feature.properties.PRODUCT || feature.properties.RE_PRODUCT_NAME || 'Layer';
          const desc = feature.properties.INFO || feature.properties.RE_TOOLTIP || feature.properties.OUTLOOK || '';
          layerObj.bindPopup(
            `<strong>${title}</strong><br>${desc}`
          );
        }
      });
      layer._geoJsonLayer.addTo(layer);
    } catch (e) {
      console.error('Failed to load RealEarth layer:', url, e);
    }
  }

  layer._refresh = loadData;
  loadData();
  return layer;
}

// Define layers and their names/URLs
const realEarthLayers = [
  {
    name: 'Tropical Weather Forecast',
    url: 'https://realearth.ssec.wisc.edu/api/shapes?products=TSFCST'
  },
  {
    name: 'Excessive Rain Outlook',
    url: 'https://realearth.ssec.wisc.edu/api/shapes?products=WPC-ExcessiveRain'
  },
  {
    name: 'Winter Storm Severity Index',
    url: 'https://realearth.ssec.wisc.edu/api/shapes?products=WPC-WSSI'
  },
  // ProbSevere will be handled separately
  {
    name: 'SPC Convective Outlook Day 1',
    url: 'https://realearth.ssec.wisc.edu/api/shapes?products=SPCcoday1'
  }
];

// Create layers (excluding ProbSevere)
const realEarthLayerObjs = realEarthLayers.map(l => ({
  name: l.name,
  layer: createRealEarthLayer(l.url)
}));

// Create ProbSevere layer separately, using the dedicated pane
const probSevereLayerObj = {
  name: 'ProbSevere',
  layer: createRealEarthLayer('https://realearth.ssec.wisc.edu/api/shapes?products=PROBSEVEREV3', 'probSeverePane')
};

// Add toggles to a Leaflet control on the map
const realEarthControl = L.control({ position: 'bottomleft' });

realEarthControl.onAdd = function(map) {
  const div = L.DomUtil.create('div', 'realearth-key');
  div.style.background = '#222';
  div.style.color = '#fff';
  div.style.padding = '1em';
  div.style.borderRadius = '8px';
  div.style.boxShadow = '0 2px 8px rgba(0,0,0,0.5)';
  div.style.fontSize = '1em';
  div.style.maxWidth = '300px';
  div.innerHTML = `<strong>Layers</strong><br>`;
  realEarthLayerObjs.forEach((obj, i) => {
    const id = `realEarthToggle${i}`;
    div.innerHTML += `<label style="display:block; margin:0.5em 0;">
      <input type="checkbox" id="${id}"> ${obj.name}
    </label>`;
  });
  // ProbSevere toggle
  div.innerHTML += `<label style="display:block; margin:0.5em 0;">
    <input type="checkbox" id="probSevereToggle"> ${probSevereLayerObj.name}
  </label>`;
  return div;
};
realEarthControl.addTo(map);

// Attach event listeners after control is added
setTimeout(() => {
  realEarthLayerObjs.forEach((obj, i) => {
    document.getElementById(`realEarthToggle${i}`).addEventListener('change', function(e) {
      if (e.target.checked) {
        obj.layer.addTo(map);
      } else {
        map.removeLayer(obj.layer);
      }
    });
  });
  // ProbSevere toggle
  document.getElementById('probSevereToggle').addEventListener('change', function(e) {
    if (e.target.checked) {
      probSevereLayerObj.layer.addTo(map);
    } else {
      map.removeLayer(probSevereLayerObj.layer);
    }
  });
}, 0);

// Refresh RealEarth layers every 5 minutes
setInterval(() => {
  realEarthLayerObjs.forEach(obj => {
    obj.layer._refresh();
  });
}, 300000); // 5 minutes

// Refresh ProbSevere every minute
setInterval(() => {
  probSevereLayerObj.layer._refresh();
}, 60000); // 1 minute

// Helper function to convert "0 255 0" to "#00ff00"
function rgbString(rgb) {
  if (!rgb) return null;
  if (typeof rgb === "string" && rgb.match(/^\d+\s+\d+\s+\d+$/)) {
    const [r, g, b] = rgb.split(' ').map(Number);
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
  }
  return rgb;
}
</script>
</body>
</html>
